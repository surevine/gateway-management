<?xml version="1.0" encoding="UTF-8" standalone="no"?><Events>

<Event>
	<EventTime>
		<TimeCreated>2014-11-21T10:59:15.383Z</TimeCreated>
	</EventTime>
	<EventSource>
		<System>
			<Name>Community portal</Name>
			<Environment>DEVELOPMENT</Environment>
		</System>
		<Generator>Gateway management console</Generator>
		<Device>
			<Name>Hosted web application</Name>
		</Device>
		<User>
			<EmailAddress>METHODTOCALLWILDFLY</EmailAddress>
		</User>
	</EventSource>
	<EventDetail>
		<Description>Updated global export rules.</Description>
<Update><After><Data name="globalRuleFile" value="export"/><Data name="globalRuleFileContent" value="/**  * This is a JavaScript file which defines a list of export control rules in  * the format:  *  * Rules.mandate(condition);  *  * Where condition is a clause that returns a boolean, the value of which must  * always be true if the file is to be sent. If one mandated rule returns false  * then the file will not be sent. Global variables are available by default  * for:  *   source      - Path to the file queued for transfer.  *   metadata    - A map of key-value properties for the file.  *   destination - The URI intended for the file to be sent to.  */ importClass(java.util.Arrays); importClass(java.lang.System);  // Debug: Print out initial variables for debugging. var it = metadata.keySet().iterator(); while (it.hasNext()) {  var key = it.next();  System.out.println(key +&quot; : &quot; +metadata.get(key)); }    // Rule: Don't send auxiliary files as these currently break Nexus import. Rules.mandate(!metadata.get(&quot;name&quot;).endsWith(&quot;-bundle.zip&quot;), &quot;Refusing to export bundle.&quot;); Rules.mandate(!metadata.get(&quot;name&quot;).endsWith(&quot;-sources.jar&quot;), &quot;Refusing to export sources.&quot;);  // Rule: Only send items with a valid security label. Rules.mandate(metadata.get(&quot;classification&quot;) != null, &quot;Classification is required.&quot;); Rules.mandate(metadata.get(&quot;decorator&quot;) != null, &quot;Decorator is required.&quot;); Rules.mandate(metadata.get(&quot;groups&quot;) != null &amp;&amp; metadata.get(&quot;groups&quot;).split(&quot;,&quot;).length &gt; 0,   &quot;Group metadata is invalid: &quot; +metadata.get(&quot;groups&quot;));  // Rule: Only send locally-sourced produce. //Rules.mandate(metadata.get(&quot;organisation&quot;) == &quot;local&quot;, &quot;Organisation must be local&quot;);  // Rule: Do not send anything over FTP. Rules.mandate(destination.indexOf(&quot;ftp://&quot;) !== 0, &quot;Destination scheme cannot be FTP.&quot;);  // Rule: Do not send STAFF labelled data. Rules.mandate(function() {  if (destination.equals(&quot;file:///tmp/foreign&quot;)) {   return !Arrays.asList(metadata.get(&quot;groups&quot;).split(&quot;,&quot;)).contains(&quot;STAFF&quot;);  } else {   return true;  } }(), &quot;STAFF group cannot be applied to foreign destination.&quot;);  // Rule: File copy only. //Rules.mandate(destination.indexOf(&quot;file://&quot;) === 0)  /**  * Logic for stripping out metadata we don't wish to send elsewhere.  */ //Strip security label properties if not sending on to ORG01 or ORG02. if (metadata.containsKey(&quot;organisation&quot;)) {  var organisations = Arrays.asList(metadata.get(&quot;organisation&quot;).split(&quot;,&quot;));   if (!organisations.contains(&quot;ORG01&quot;) &amp;&amp; !organisations.contains(&quot;ORG02&quot;)) {   metadata.remove(&quot;organisation&quot;);   metadata.remove(&quot;classification&quot;);   metadata.remove(&quot;nationality&quot;);   metadata.remove(&quot;groups&quot;);  } } "/></After></Update>
	</EventDetail>
</Event><Event>
	<EventTime>
		<TimeCreated>2014-11-21T10:59:19.929Z</TimeCreated>
	</EventTime>
	<EventSource>
		<System>
			<Name>Community portal</Name>
			<Environment>DEVELOPMENT</Environment>
		</System>
		<Generator>Gateway management console</Generator>
		<Device>
			<Name>Hosted web application</Name>
		</Device>
		<User>
			<EmailAddress>METHODTOCALLWILDFLY</EmailAddress>
		</User>
	</EventSource>
	<EventDetail>
		<Description>Updated global export rules.</Description>
<Update><After><Data name="globalRuleFile" value="export"/><Data name="globalRuleFileContent" value="/**  * This is a JavaScript file which defines a list of export control rules in  * the format:  *  * Rules.mandate(condition);  *  * Where condition is a clause that returns a boolean, the value of which must  * always be true if the file is to be sent. If one mandated rule returns false  * then the file will not be sent. Global variables are available by default  * for:  *   source      - Path to the file queued for transfer.  *   metadata    - A map of key-value properties for the file.  *   destination - The URI intended for the file to be sent to.  */ importClass(java.util.Arrays); importClass(java.lang.System);  // Debug: Print out initial variables for debugging. var it = metadata.keySet().iterator(); while (it.hasNext()) {  var key = it.next();  System.out.println(key +&quot; : &quot; +metadata.get(key)); }  // Rule: Don't send auxiliary files as these currently break Nexus import. Rules.mandate(!metadata.get(&quot;name&quot;).endsWith(&quot;-bundle.zip&quot;), &quot;Refusing to export bundle.&quot;); Rules.mandate(!metadata.get(&quot;name&quot;).endsWith(&quot;-sources.jar&quot;), &quot;Refusing to export sources.&quot;);  // Rule: Only send items with a valid security label. Rules.mandate(metadata.get(&quot;classification&quot;) != null, &quot;Classification is required.&quot;); Rules.mandate(metadata.get(&quot;decorator&quot;) != null, &quot;Decorator is required.&quot;); Rules.mandate(metadata.get(&quot;groups&quot;) != null &amp;&amp; metadata.get(&quot;groups&quot;).split(&quot;,&quot;).length &gt; 0,   &quot;Group metadata is invalid: &quot; +metadata.get(&quot;groups&quot;));  // Rule: Only send locally-sourced produce. //Rules.mandate(metadata.get(&quot;organisation&quot;) == &quot;local&quot;, &quot;Organisation must be local&quot;);  // Rule: Do not send anything over FTP. Rules.mandate(destination.indexOf(&quot;ftp://&quot;) !== 0, &quot;Destination scheme cannot be FTP.&quot;);  // Rule: Do not send STAFF labelled data. Rules.mandate(function() {  if (destination.equals(&quot;file:///tmp/foreign&quot;)) {   return !Arrays.asList(metadata.get(&quot;groups&quot;).split(&quot;,&quot;)).contains(&quot;STAFF&quot;);  } else {   return true;  } }(), &quot;STAFF group cannot be applied to foreign destination.&quot;);  // Rule: File copy only. //Rules.mandate(destination.indexOf(&quot;file://&quot;) === 0)  /**  * Logic for stripping out metadata we don't wish to send elsewhere.  */ //Strip security label properties if not sending on to ORG01 or ORG02. if (metadata.containsKey(&quot;organisation&quot;)) {  var organisations = Arrays.asList(metadata.get(&quot;organisation&quot;).split(&quot;,&quot;));   if (!organisations.contains(&quot;ORG01&quot;) &amp;&amp; !organisations.contains(&quot;ORG02&quot;)) {   metadata.remove(&quot;organisation&quot;);   metadata.remove(&quot;classification&quot;);   metadata.remove(&quot;nationality&quot;);   metadata.remove(&quot;groups&quot;);  } } "/></After></Update>
	</EventDetail>
</Event></Events>